Conflux core
===
Conflux 的核心是通过其 TreeGraph 账本结构和 GHAST 共识协议极大幅度的提高了区块链的吞吐率（且降低了延迟），并且没有降低其去中心化程度和安全性。

达到了一个安全和性能的平衡，
通过把一个创新的账本结构表示为一个树图结构，这个树图结构的作用是把问题分解成一个共识，
实际上就是大家可以并发出块，最后大家要对所有的区块全序达成共识。
相当于把出块和定序的过程能够分开，相互之间没有太多的依赖，这样就可以达到一个对吞吐率最好的利用。

Conflux能够让所有参与的节点安全的对区块的全序达成共识。
出块出得快了，带来的问题是在区块链上会产生很多分叉，我们在分叉里边，总是能够找到一条主链，我们叫做枢轴链。
那么为了找到这样一条链，我们可以根据最重子树的规则，使得在寻找这样一个链的过程中所有的参与节点都能够贡献它的力量，这样就使得我们能够完美的去利用51%的假设，达到一个和比特币一样的安全特性。
一旦选择了主链以后，我们就会有一个确定的算法，能够根据这个主链把所有区块的顺序定下来，
通过这种方法我们可以允许大家很快出块，又不用像比特币一样去限制一个很大的出块时间间隔。
因为比特币要求所有的区块尽可能在一条链上，这样才能够确保安全，但是我们有了树图算法以后，就可以允许大家把出块的机率提高，从而把TPS相应的提高很多

### TreeGraph

TreeGrahp 实现了全序，可支持智能合约。

1. 在 conflux 账本结构中区块间的引用有两种：父边和引用边。
2. 如果只看父边是一个Tree，如果所有都看是一个DAG
3. 新区块生成的时候会创建对最新pivot block 的父边引用(每个区块只有一个父区块，父引用)，并且会引用所有其观测到的，未被引用的block，用于确定 happen-before 关系
4. 根据最大生成子树规则从创世区块开始确定 pivot block
5. 主链上的每一个区块确定一个 Epoch, 在分叉上的区块属于哪个 Epoch，是由第一个产生在它之后的主链区块所在的 Epoch 决定的
6. 在同一个epoch 内部，用拓扑排序确定区块顺序，出现平局使用哈希值排序




##### 一句话总结
树图是一种特殊的DAG，DAG相对于链式结构可以提高吞吐率（并行出块），节省资源，提高安全性
树图之于DAG的不同之处在于其中的边分为两种，一种父边指向父区块，只有一条，另外一种是引用边，可以有多条，用于表示happen before 关系，从而实现全序（为了支持智能合约）

如何实现全序：
通过 Ghost 规则确定主链，通过 Epoch 规则确定区块的大体顺序，通过拓扑和哈希排序实现同一 Epoch 内区块的顺序


问题：
1. 最大子树的选择是何时进行的：每隔一段时间选择一次？还是生成的区块到达一定数量之后选择，还是其他？
2. 区块生成的时候应该在其观测到的最新的 pivot block 上继续出块，当然该pivot block 最终可能会变？
3. 区块是先生成，然后选择pivot block，选择完之后会更新对应block中信息么？如果更新的话，岂不会改变block 的hash？
4. 在同一个区块内部的 tx 的顺序，是有矿工打包时选择tx 的规则所确定.
5. 挖矿pivot block跟其他block的奖励是一样的么？
6. 因为账本结构的复杂性，会不会出现不同节点账本不一致的情况？经过一段时间同步会确定下来（一致）大概经过五六个 Epoch
7. ghast 和 ghost 的区别


### 参考

[Conflux的自我进化：从DAG到树图](https://learnblockchain.cn/2019/04/12/conflux-tree-graph)
[漫谈区块图技术之XDAG和Conflux](https://learnblockchain.cn/2019/01/11/dev_meeting_9/)